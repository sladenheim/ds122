---
title: Viterbi Algorithm
author: "CDS DS-122<br>Boston University"
format: 
    revealjs:
        math: true
        css: 
        - styles.css
        html-math-method: mathjax
        highlight-style: github
        slide-number: true
        show-slide-number: all
        chalkboard: true 
---

## Umbrella Problem
:::{style="font-size: .8em"}
:::{.columns}
::: {.column width="20%"}
:::{.center-text}
<img src="images/hmm/umbrella.png" width=300/>
:::
:::

::: {.column width="80%"}
A student is studying for an exam in a room without any windows. Every day she wants to know whether it is rainy or sunny outside. However, her only access to the outside world is when she sees her housemate leaving the house with or without an umbrella each morning. 
:::
:::

__Question__: Given the housemateâ€™s behavior:

- Day 1: no umbrella
- Day 2: umbrella
- Day 3: umbrella
- Day 4: no umbrella

What can the student infer about the weather on each of those days?
:::

## Umbrella Problem
:::{style="font-size: .8em"}

Model assumptions: Markov property, stationarity, output independence.


:::{.center-text}
<img src="images/hmm/HMM_diagram_no_start.svg" width=900/>
:::

Given sequence of observations $O=\left(o_1,o_2,o_3,o_4\right)=(0,1,1,0),$ find the sequence of hidden states $X=\left(x_1,x_2,x_3,x_4\right)$ that best describes the observations $O$.

:::

## Learning Objectives
:::{style="font-size: .8em"}

- The Viterbi algorithm:
    * Key properties
    * Connection to the brute-force approach
    * Main stages:
        1. Initialization
        2. Forward pass
        3. Backward pass
    * Implementation in Python

:::

## Key Properties
:::{style="font-size: .8em"}
- Efficient alternative to brute-force decoding  
- Time complexity: $\mathcal{O}(N^2T)$  
- Step-wise approach: operates step-by-step over observations $o_i$ in <br> sequence $O$  
- At each step:
  - Maximizes joint probability across hidden states  
  - Stores the state leading to the best score  
- Recursion: each step builds on the previous one  
- Viterbi path: the optimal hidden state path   

:::

## Main Stages
:::{style="font-size: .8em"}
The Vitebri algorithm can be split into three main stages:

1. _Initialization_,
2. _Forward pass_,
3. _Backward pass_.

Before we proceed with the discussion of the stages of the Viterbi algorithm, we need to introduce its _auxiliary matrices_, $C$ and $D$:

- $C$ is used to store the intermediate probabilities
- $D$ contains the previously visited hidden states 
- $C$ and $D$ are $N \times T$ matrices, where $N$ is the number of possible hidden states and $T$ is the length of the observed sequence.
:::

## Initialization
:::{style="font-size: .8em"}
The initialization stage populates the first column of matrix $C$, $C_{i1}$, and the first column of matrix $D$, $D_{i1}$. 

To find the first column of $C$, we use the following expression:

$$C_{i1} = P(o_0 | x_0 = q_i) P(x_0 = q_i) = B_{cindex(o_0)i}\pi_i. $$

where $cindex(o_0)$ is the index of the first observation in the emission matrix.

In the umbrella problem, on day 0, the housemate had no umbrella: $o_0 = 0.$ Hence, $B_{cindex(o_0)i}$ becomes $B_{1i}$ and we obtain

$$C_{11} = P(0|S)P(S) = B_{11}\pi_1 = 0.8 \cdot 0.6 = 0.48,$$

$$C_{21} = P(0|R)P(R) = B_{12}\pi_2 = 0.4 \cdot 0.4 = 0.16.$$
:::

## Initialization
:::{style="font-size: .8em"}
The first column of $D$ contains only zeros for any problem, because there are no hidden states preciding the initial state:

$$D_{i1} = 0.$$

:::{.center-text}
<img src="images/hmm/Viterbi_diagram_initialization.svg" width=600/>
:::

:::

## Initialization
:::{style="font-size: .8em"}
At the end of this stage, matrices $C$ and $D$ for the umbrella problem can be written as

$$C = \begin{bmatrix}0.48 & \ast & \ast & \ast \\ 0.16 & \ast & \ast & \ast \\  \end{bmatrix} \text{ and } D = \begin{bmatrix}0 & \ast & \ast & \ast \\ 0 & \ast & \ast & \ast \\  \end{bmatrix},$$

where $\ast$ denotes the components that haven't been computed yet. 

The matrices are completed in the forward pass.
:::

## Forward Pass
:::{style="font-size: .8em"}

:::

## Forward Pass
:::{style="font-size: .8em"}
The final result of the forward pass consists of fully defined matrices $C$ and $D$:

$$\small{C = \begin{bmatrix}0.48 & 0.0672 & 0.009408 & 0.009953 \\ 0.16 & 0.0864 & 0.03110 & 0.007465  \end{bmatrix},D = \begin{bmatrix} 0 & 1 & 1 & 2\\  0 & 1 & 2 & 2\end{bmatrix}.}$$

:::{.center-text}
<img src="images/hmm/Viterbi_diagram_forward.svg" width=700/>
:::

:::

## Backward Pass
:::{style="font-size: .8em"}

The backward pass constructs the Viterbi path, the optimal hidden state sequence for observed data.  

- Step 1: Find the highest probability in the last column of matrix $C$, say column $T$:  
  $$s = \operatorname{argmax}_{i} C_{iT}$$  
- Step 2: Use matrix $D$ to trace back the path. That is, start from entry $D_{sT}$ and move backward. 

In the umbrella problem, $s=1$. It corresponds to hidden state $Sunny$. Thus, the fourth state in the hidden state sequence $X = (x_0,x_1, x_2, x_3)$ is $Sunny$: $x_3 = S.$

:::

## Backward Pass
:::{style="font-size: .8em"}
Moreover, $D_{14}$ is equal to 2:

$$D = \begin{bmatrix} 0 & 1 & 1 & \mathbf{2}\\  0 & 1 & 2 & 2\end{bmatrix}.$$

This value directs us to the second row of matrix $D$ that corresponds with hidden state $Rainy$. Hence, $Rainy$ becomes the third state in the hidden state sequence: $x_2 = R.$

Since $D_{23}$ is also equal to 2: 

$$\small{D = \begin{bmatrix} 0 & 1 & 1 & \mathbf{2}\\  0 & 1 & \mathbf{2} & 2\end{bmatrix},}$$

we find that $x_1$ is $Rainy$ and so on.
:::

## Backward Pass
:::{style="font-size: .8em"}

The complete path through matrix $D$ is shown below:

$$\small{D = \begin{bmatrix} \mathbf{0} & 1 & 1 & \mathbf{2}\\  0 & \mathbf{1} & \mathbf{2} & 2\end{bmatrix}.}$$

The Viterbi path for the umbrella problem is then $(S, R, R, S).$ 

:::
## Group Question 1
:::{style="font-size: .8em"}

```{python}
from IPython.core.display import HTML

def generate_html():
    return r"""
    <div class="blue-box">
        <p>
    Given the following matrix \(D\):

$$\small{D = \begin{bmatrix} 0 & 1 & 3 & 2 & 3\\
                      0 & 2 & 4 & 1 & 3\\
                      0 & 2 & 4 & 1 & 4\\
                      0 & 4 & 4 & 3 & 1
      \end{bmatrix}.}$$

Find the Viterbi path, if the maximum entry in the last column of matrix \(C\) is located in the first row. <br>
a. 3 1 3 2 0 <br>
b. 1 3 1 3 2 <br>
c. 2 3 1 3 1 <br>
d. 0 2 3 1 3 <br>
e. 3 4 2 3 1
        </p>
    </div>
    """
html_content = generate_html()
display(HTML(html_content))
```

:::

## Group Question 2
:::{style="font-size: .8em"}

```{python}
import numpy as np
```

```{python}
from IPython.core.display import HTML

def generate_html():
    return r"""
    <div class="blue-box">
        <p>
    Given the code below. What is the final answer for the umbrella problem?
        </p>
    </div>
    """
html_content = generate_html()
display(HTML(html_content))
```
```{python}
#| echo: true
def Viterbi(y, A, B, Pi):
    N = A.shape[1] # cardinality of the state space
    T = len(y) # length of the observed sequence
    # Initialize C & D
    C = np.empty((N, T), 'd') #'d' stands for type double
    D = np.empty((N, T), 'B') #'B' stands for type unsigned integer 

    # Initialization stage
    C[:, 0] = B[y[0], :] * Pi.T
    D[:, 0] = 0

    # Forward pass
    for i in range(1, T):
        C[:, i] = np.max(B[y[i], :, np.newaxis] * A * C[:, i - 1], 1)
        D[:, i] = np.argmax(B[y[i], :, np.newaxis] * A * C[:, i - 1], 1)
    D[:,1:] =  D[:,1:] + 1 # hidden states indices start with 1

    # Backward pass
    x = np.empty(T, 'B')
    x[-1] = np.argmax(C[:, T - 1]) + 1 # finds the value of s
    for i in reversed(range(1, T)): 
        x[i - 1] = D[x[i] - 1, i]

    return x, C, D
```

:::

## Python Implementation 
:::{style="font-size: .8em"}
```{python}
#| echo: true
# HMM and observed sequence
A = np.array([[0.7,0.4],[0.3,0.6]])
B = np.array([[0.8, 0.4],[0.2, 0.6]])
Pi = np.array([[0.6],[0.4]])

print("Transition matrix: \n", A)
print("Emission matrix: \n", B)
print("Initial state distribution: \n", Pi)

O = np.array([0,1,1,0])
print("Observed sequence: \n", O)
```
:::

## Python Implementation 
:::{style="font-size: .8em"}
```{python}
#| echo: true
# Result
X, C, D = Viterbi(O,A,B,Pi)
print("Matrix C: \n", C)
print("Matrix D: \n", D)
#print("Answer: \n", X)
```

:::

<!-- No group questions, because the next lecture is when we actually practice. -->
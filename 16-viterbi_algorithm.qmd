---
title: Viterbi Algorithm
author: "CDS DS-122<br>Boston University"
format: 
    revealjs:
        math: true
        css: 
        - styles.css
        html-math-method: mathjax
        highlight-style: github
        slide-number: true
        show-slide-number: all
        chalkboard: true 
filters:
    - pyodide
---

## Learning Objectives
:::{style="font-size: .8em"}

- The Viterbi algorithm:
    * Key properties
    * Connection to the brute-force approach
    * Main stages:
        1. Initialization
        2. Forward pass
        3. Backward pass
    * Implementation in Python
    * Application to the umbrella problem

:::

## Umbrella Problem
:::{style="font-size: .8em"}
:::{.columns}
::: {.column width="20%"}
:::{.center-text}
<img src="images/hmm/umbrella.png" width=300/>
:::
:::

::: {.column width="80%"}
A student is studying for an exam in a room without any windows. Every day she wants to know whether it is rainy or sunny outside. However, her only access to the outside world is when she sees her housemate leaving the house with or without an umbrella each morning. 
:::
:::

__Question__: Given the housemateâ€™s behavior:

- Day 1: no umbrella
- Day 2: umbrella
- Day 3: umbrella
- Day 4: no umbrella

What can the student infer about the weather on each of those days?
:::

## Umbrella Problem
:::{style="font-size: .8em"}

Model assumptions: Markov property, stationarity, output independence.


:::{.center-text}
<img src="images/hmm/HMM_diagram_no_start.svg" width=900/>
:::

The intial probabilities are 0.6 and 0.4 for a sunny day and a rainy day, respectively.

Given sequence of observations $\small O=\left(o_0, o_1,o_2,o_3\right)=(0,1,1,0),$ find the sequence of hidden states $\small X=\left(x_0, x_1,x_2,x_3\right)$ that best describes the observations $\small O$.

:::

## Viterbi Algorithm: Properties
:::{style="font-size: .8em"}
- Efficient alternative to brute-force decoding  
- Time complexity: $\small \mathcal{O}(N^2T)$  
- Step-wise approach: operates step-by-step over observations $\small o_i$ in <br> sequence $\small O$  
- At each step:
  - Maximizes joint probability across hidden states  
  - Stores the state leading to the best score  
- Recursion: each step builds on the previous one  
- Viterbi path: the optimal hidden state path   

:::

## Viterbi Algorithm: Main Stages
:::{style="font-size: .8em"}
The Vitebri algorithm can be split into three main stages:

1. __Initialization__,
2. __Forward pass__,
3. __Backward pass__.

Before we proceed with the discussion of the stages of the Viterbi algorithm, we need to introduce its __auxiliary matrices__, $\small C$ and $\small  D$:

- $\small  C$ is used to store the intermediate probabilities
- $\small  D$ contains the previously visited hidden states 
- $\small  C$ and $\small  D$ are $\small N \times T$ matrices, where $\small N$ is the number of possible hidden states and $\small T$ is the length of the observed sequence.
:::

## Initialization
:::{style="font-size: .8em"}
The initialization stage populates the first column of matrix $\small C$, $\small C_{i1}$, and the first column of matrix $\small D$, $\small D_{i1}$. 

To find the first column of $C$, we use the following expression:

$$\small C_{i1} = P(o_0 | x_0 = q_i) P(x_0 = q_i) = B_{cindex(o_0)i}\pi_i. $$

where $\small cindex(o_0)$ is the index of the first observation in the emission matrix.

In the umbrella problem, on day 0, the housemate had no umbrella: $\small o_0 = 0.$ Hence, $\small B_{cindex(o_0)i}$ becomes $\small B_{1i}$ and we obtain

$$\small C_{11} = P(0|S)P(S) = B_{11}\pi_1 = 0.8 \cdot 0.6 = 0.48,$$

$$\small C_{21} = P(0|R)P(R) = B_{12}\pi_2 = 0.4 \cdot 0.4 = 0.16.$$
:::

## Initialization
:::{style="font-size: .8em"}
The first column of $\small D$ contains only zeros for any problem, because there are no hidden states preciding the initial state:

$$\small  D_{i1} = 0.$$

:::{.center-text}
<img src="images/hmm/Viterbi_diagram_initialization.svg" width=600/>
:::

:::

## Initialization
:::{style="font-size: .8em"}
At the end of this stage, matrices $\small C$ and $\small D$ for the umbrella problem can be written as

$$\small C = \begin{bmatrix}0.48 & \ast & \ast & \ast \\ 0.16 & \ast & \ast & \ast \\  \end{bmatrix} \text{ and } D = \begin{bmatrix}0 & \ast & \ast & \ast \\ 0 & \ast & \ast & \ast \\  \end{bmatrix},$$

where $\small  \ast$ denotes the components that haven't been computed yet. 

The matrices are completed in the forward pass.
:::

## Forward Pass
:::{style="font-size: .8em"}
:::{.center-text}
<span style="color:gray;">This page is intentionally left blank.</span>
:::

:::

## Forward Pass
:::{style="font-size: .8em"}
The final result of the forward pass consists of fully defined matrices $\small  C$ and $\small  D$:

$$\small{C = \begin{bmatrix}0.48 & 0.0672 & 0.009408 & 0.009953 \\ 0.16 & 0.0864 & 0.03110 & 0.007465  \end{bmatrix},D = \begin{bmatrix} 0 & 1 & 1 & 2\\  0 & 1 & 2 & 2\end{bmatrix}.}$$

:::{.center-text}
<img src="images/hmm/Viterbi_diagram_forward.svg" width=700/>
:::

:::

## Backward Pass
:::{style="font-size: .8em"}

The backward pass constructs the Viterbi path, the optimal hidden state sequence for observed data.  

- Step 1: Find the highest probability in the last column of matrix $\small C$, say column $\small T$:  
  $$\small s = \operatorname{argmax}_{i} C_{iT}$$  
- Step 2: Use matrix $\small D$ to trace back the path. That is, start from entry $\small D_{sT}$ and move backward. 

In the umbrella problem, $\small s=1$. It corresponds to hidden state $Sunny$. Thus, the fourth state in the hidden state sequence $\small X = (x_0,x_1, x_2, x_3)$ is $Sunny$: $\small x_3 = S.$

:::

## Backward Pass
:::{style="font-size: .8em"}
Moreover, $\small D_{14}$ is equal to 2:

$$\small D = \begin{bmatrix} 0 & 1 & 1 & \mathbf{2}\\  0 & 1 & 2 & 2\end{bmatrix}.$$

This value directs us to the second row of matrix $\small D$ that corresponds with hidden state $Rainy$. Hence, $Rainy$ becomes the third state in the hidden state sequence: $\small x_2 = R.$

Since $\small D_{23}$ is also equal to 2: 

$$\small \small{D = \begin{bmatrix} 0 & 1 & 1 & \mathbf{2}\\  0 & 1 & \mathbf{2} & 2\end{bmatrix},}$$

we find that $\small x_1$ is $Rainy$ and so on.
:::

## Backward Pass
:::{style="font-size: .8em"}

The complete path through matrix $\small D$ is shown below:

$$\small \small{D = \begin{bmatrix} \mathbf{0} & 1 & 1 & \mathbf{2}\\  0 & \mathbf{1} & \mathbf{2} & 2\end{bmatrix}.}$$

The Viterbi path for the umbrella problem is then $\small (S, R, R, S).$ 

:::
## Group Question 1
:::{style="font-size: .8em"}

```{python}
from IPython.core.display import HTML

def generate_html():
    return r"""
    <div class="blue-box">
        <p>
    Given the following matrix \(\small D\):

$$\small{D = \begin{bmatrix} 0 & 1 & 3 & 2 & 3\\
                      0 & 2 & 4 & 1 & 3\\
                      0 & 2 & 4 & 1 & 4\\
                      0 & 4 & 4 & 3 & 1
      \end{bmatrix}.}$$

Find the Viterbi path, if the maximum entry in the last column of matrix \(\small C\) is located in the first row. <br>
a. 3 1 3 2 0 <br>
b. 1 3 1 3 2 <br>
c. 2 3 1 3 1 <br>
d. 0 2 3 1 3 <br>
e. 3 4 2 3 1
        </p>
    </div>
    """
html_content = generate_html()
display(HTML(html_content))
```

:::

## Group Question 2
:::{style="font-size: .7em"}

```{python}
import numpy as np
```

```{python}
from IPython.core.display import HTML

def generate_html():
    return r"""
    <div class="blue-box">
        <p>
    Given the code below. What is the final answer for the umbrella problem?
        </p>
    </div>
    """
html_content = generate_html()
display(HTML(html_content))
```
```{python}
#| echo: true
def Viterbi(y, A, B, Pi):
    N = A.shape[1] # cardinality of the state space
    T = len(y) # length of the observed sequence
    # Initialize C & D
    C = np.empty((N, T), 'd') #'d' stands for type double
    D = np.empty((N, T), 'B') #'B' stands for type unsigned integer 

    # Initialization stage
    C[:, 0] = B[y[0], :] * Pi.T
    D[:, 0] = 0

    # Forward pass
    for i in range(1, T):
        C[:, i] = np.max(B[y[i], :, np.newaxis] * A * C[:, i - 1], 1)
        D[:, i] = np.argmax(B[y[i], :, np.newaxis] * A * C[:, i - 1], 1)
    D[:,1:] =  D[:,1:] + 1 # hidden states indices start with 1

    # Backward pass
    x = np.empty(T, 'B')
    x[-1] = np.argmax(C[:, T - 1]) + 1 # finds the value of s
    for i in reversed(range(1, T)): 
        x[i - 1] = D[x[i] - 1, i]

    return x, C, D
```

:::

## Python Implementation 
:::{style="font-size: .8em"}
```{python}
#| echo: true
# HMM and observed sequence
A = np.array([[0.7,0.4],[0.3,0.6]])
B = np.array([[0.8, 0.4],[0.2, 0.6]])
Pi = np.array([[0.6],[0.4]])

print("Transition matrix: \n", A)
print("Emission matrix: \n", B)
print("Initial state distribution: \n", Pi)

O = np.array([0,1,1,0])
print("Observed sequence: \n", O)
```
:::

## Python Implementation 
:::{style="font-size: .8em"}
```{python}
#| echo: true
# Result
X, C, D = Viterbi(O,A,B,Pi)
print("Matrix C: \n", C)
print("Matrix D: \n", D)
print("Answer: \n", X)
```

:::

<!-- No group questions, because the next lecture is when we actually practice. -->